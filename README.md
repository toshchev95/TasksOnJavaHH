# TasksOnJavaHH

## Решение задач

---------------------------

### The first task. The island.

---------------------------

#### Алгоритм:

0. Инициализация вспомогательной матрицы состояний, размеры которой совпадают с размерами матрицы острова.
Вычисление количества состояний white_state.

1. Найдём глобальный минимум матрицы a[i][j]. От a[i][j] для каждой компоненты связности мы ищем минимум и 
максимум среди всех её соседей, которые не принадлежат этой компоненте(цифра не ровно нашей), после чего, если 
максимум больше цифры, то a[i][j] заполняем минимумом. Разницу a[i][j] и минимума прибавим к общему объему воды.
Как только компоненту связности увеличить больше нельзя, количество состояний white_state уменьшаем на единицу.

2. Пока в вспомогательной матрице существует хотя бы одно white_state, выполняем шаг 1.

3. Возвращаем общий объём заполненной воды на острове.

Состояния:

white_state = 1 - вода не наливается в ячейке матрицы;

gray_state = 2 -  вода наливается в ячейке матрицы;

black_state = 0 - вода переливается либо на границе острова, либо вдоль ячейек высотой не больше нашей;

---------------------------

### The second task. An infinity.

---------------------------

#### Алгоритм:

1. Бесконечную последовательность цифр делим на части, где длина новой последовательности будет не меньше
фиксированной длины. Например, 100.

2. В каждой такой новой последовательности цифр ищем совпадение с шаблоном из stdin. Для этого применяется
алгоритм поиска подстроки в строке - алгоритм Кнута - Морриса - Пратта. Если поиск ничего не дал, то добавляем
суффикс строки, на котором приостановился поиск в строке, к новой строке на шаге 1.